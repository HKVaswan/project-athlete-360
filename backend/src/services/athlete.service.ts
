/**
 * src/services/athlete.service.ts
 * --------------------------------------------------------------------------
 * Athlete Service (Enterprise Edition)
 *
 * Responsibilities:
 *  - Athlete creation & linking with user accounts
 *  - Profile & performance data management
 *  - Institution & coach assignment with plan restrictions
 *  - Pagination, filtering, and analytics
 *  - Fully audited and subscription-aware
 * --------------------------------------------------------------------------
 */

import prisma from "../prismaClient";
import logger from "../logger";
import { Errors } from "../utils/errors";
import { paginate, computeNextCursor } from "../utils/pagination";
import { quotaService } from "./quota.service";
import { recordAuditEvent } from "./audit.service";
import { checkActiveSubscription } from "./subscription.service";

/* ---------------------------------------------------------------------------
   🧩 Create Athlete (Subscription & Quota Enforced)
--------------------------------------------------------------------------- */
export const createAthlete = async (data: {
  userId: string;
  sport: string;
  position?: string;
  dateOfBirth?: Date;
  gender?: string;
  bio?: string;
  heightCm?: number;
  weightKg?: number;
  institutionId?: string;
  coachId?: string | null;
}, actor?: { id: string; role: string; ip?: string }) => {

  const user = await prisma.user.findUnique({ where: { id: data.userId } });
  if (!user) throw Errors.NotFound("User not found for athlete creation");

  const existingAthlete = await prisma.athlete.findUnique({ where: { userId: data.userId } });
  if (existingAthlete) throw Errors.Duplicate("Athlete already exists for this user");

  // 🔐 Subscription & quota enforcement (if institution provided)
  if (data.institutionId) {
    const institution = await prisma.institution.findUnique({ where: { id: data.institutionId } });
    if (!institution) throw Errors.NotFound("Institution not found");

    // Ensure institution has an active subscription
    await checkActiveSubscription(institution.id);

    // Ensure within quota limits
    await quotaService.ensureWithinQuota(institution.id, "athletes");
  }

  const athlete = await prisma.athlete.create({
    data: { ...data, joinedAt: new Date() },
    include: { user: true, institution: true },
  });

  logger.info(`🏋️ Athlete created for user ${data.userId}`);

  await recordAuditEvent({
    actorId: actor?.id || data.userId,
    actorRole: actor?.role || "system",
    ip: actor?.ip,
    action: "ATHLETE_CREATE",
    details: { athleteId: athlete.id, institutionId: data.institutionId },
  });

  return sanitizeAthlete(athlete);
};

/* ---------------------------------------------------------------------------
   📋 Get Athlete by ID
--------------------------------------------------------------------------- */
export const getAthleteById = async (id: string, actor?: { id: string; role: string }) => {
  const athlete = await prisma.athlete.findUnique({
    where: { id },
    include: {
      user: { select: { id: true, name: true, email: true, username: true, role: true } },
      institution: { select: { id: true, name: true } },
      coach: { select: { id: true, name: true, username: true } },
      performances: true,
    },
  });
  if (!athlete) throw Errors.NotFound("Athlete not found");

  await recordAuditEvent({
    actorId: actor?.id,
    actorRole: actor?.role,
    action: "ATHLETE_VIEW",
    details: { athleteId: id },
  });

  return sanitizeAthlete(athlete);
};

/* ---------------------------------------------------------------------------
   🔍 Filtered Athlete List (Paginated)
--------------------------------------------------------------------------- */
export const getAthletes = async (query: any, actor?: { id: string; role: string }) => {
  const where: any = {};

  if (query.search) {
    const s = String(query.search).trim();
    where.OR = [
      { user: { name: { contains: s, mode: "insensitive" } } },
      { user: { username: { contains: s, mode: "insensitive" } } },
    ];
  }

  if (query.sport) where.sport = { equals: query.sport, mode: "insensitive" };
  if (query.gender) where.gender = { equals: query.gender, mode: "insensitive" };
  if (query.institutionId) where.institutionId = query.institutionId;
  if (query.coachId) where.coachId = query.coachId;

  const { prismaArgs, meta } = await paginate(query, "offset", {
    countFn: (where) => prisma.athlete.count({ where }),
    where,
    includeTotal: true,
  });

  const athletes = await prisma.athlete.findMany({
    ...prismaArgs,
    where,
    include: {
      user: { select: { id: true, name: true, email: true, username: true } },
      institution: { select: { id: true, name: true } },
      coach: { select: { id: true, name: true } },
    },
  });

  if (query.cursor) meta.nextCursor = computeNextCursor(athletes);

  await recordAuditEvent({
    actorId: actor?.id,
    actorRole: actor?.role,
    action: "ATHLETE_LIST_VIEW",
    details: { filters: query },
  });

  return { data: athletes.map(sanitizeAthlete), meta };
};

/* ---------------------------------------------------------------------------
   ✏️ Update Athlete Profile
--------------------------------------------------------------------------- */
export const updateAthlete = async (
  athleteId: string,
  updates: {
    sport?: string;
    position?: string;
    bio?: string;
    heightCm?: number;
    weightKg?: number;
    coachId?: string | null;
    institutionId?: string;
  },
  actor?: { id: string; role: string; ip?: string }
) => {
  const existing = await prisma.athlete.findUnique({ where: { id: athleteId } });
  if (!existing) throw Errors.NotFound("Athlete not found");

  // Check if actor has permission
  if (actor?.role === "coach" && existing.coachId !== actor.id)
    throw Errors.Forbidden("You are not authorized to modify this athlete.");

  const athlete = await prisma.athlete.update({
    where: { id: athleteId },
    data: { ...updates },
    include: { user: true, institution: true, coach: true },
  });

  await recordAuditEvent({
    actorId: actor?.id,
    actorRole: actor?.role,
    ip: actor?.ip,
    action: "ATHLETE_UPDATE",
    details: { athleteId },
  });

  logger.info(`Athlete ${athleteId} updated by ${actor?.id || "system"}`);
  return sanitizeAthlete(athlete);
};

/* ---------------------------------------------------------------------------
   🧑‍🏫 Assign Coach (Quota Enforced)
--------------------------------------------------------------------------- */
export const assignCoach = async (athleteId: string, coachId: string, actor?: { id: string; role: string }) => {
  const athlete = await prisma.athlete.findUnique({ where: { id: athleteId } });
  if (!athlete) throw Errors.NotFound("Athlete not found");

  const coach = await prisma.user.findUnique({ where: { id: coachId } });
  if (!coach || coach.role !== "coach") throw Errors.BadRequest("Invalid coach");

  // Quota enforcement — prevent exceeding coach limit
  await quotaService.ensureCoachHasCapacity(coachId);

  const updated = await prisma.athlete.update({
    where: { id: athleteId },
    data: { coachId },
  });

  await recordAuditEvent({
    actorId: actor?.id,
    actorRole: actor?.role,
    action: "ATHLETE_COACH_ASSIGN",
    details: { athleteId, coachId },
  });

  logger.info(`Coach ${coachId} assigned to athlete ${athleteId}`);
  return sanitizeAthlete(updated);
};

/* ---------------------------------------------------------------------------
   ❌ Soft Delete Athlete (Audited)
--------------------------------------------------------------------------- */
export const deleteAthlete = async (athleteId: string, actor?: { id: string; role: string; ip?: string }) => {
  const athlete = await prisma.athlete.findUnique({ where: { id: athleteId } });
  if (!athlete) throw Errors.NotFound("Athlete not found");

  await prisma.athlete.update({
    where: { id: athleteId },
    data: { deleted: true, deletedAt: new Date() },
  });

  await recordAuditEvent({
    actorId: actor?.id,
    actorRole: actor?.role,
    ip: actor?.ip,
    action: "ATHLETE_DELETE",
    details: { athleteId },
  });

  logger.warn(`Athlete ${athleteId} soft-deleted`);
  return { success: true };
};

/* ---------------------------------------------------------------------------
   📊 Performance Summary (for analytics dashboard)
--------------------------------------------------------------------------- */
export const getPerformanceSummary = async (athleteId: string) => {
  const athlete = await prisma.athlete.findUnique({
    where: { id: athleteId },
    include: { performances: true },
  });
  if (!athlete) throw Errors.NotFound("Athlete not found");

  const totalSessions = athlete.performances.length;
  const avgScore =
    totalSessions > 0
      ? athlete.performances.reduce((sum, p) => sum + (p.score || 0), 0) / totalSessions
      : 0;

  return { totalSessions, avgScore };
};

/* ---------------------------------------------------------------------------
   🧹 Sanitize athlete object
--------------------------------------------------------------------------- */
const sanitizeAthlete = (athlete: any) => {
  if (!athlete) return null;
  const sanitized = { ...athlete };
  if (athlete.user) {
    const { passwordHash, refreshToken, ...safeUser } = athlete.user;
    sanitized.user = safeUser;
  }
  return sanitized;
};