/**
 * src/middleware/ipBlocklist.middleware.ts
 * --------------------------------------------------------------------------
 * üö´ IP Blocklist Middleware (Enterprise Grade)
 *
 * Purpose:
 *  - Prevent access from known malicious or high-risk IPs.
 *  - Integrates with AbuseIPDB, Redis cache, and local allow/deny lists.
 *  - Supports real-time dynamic updates (via Redis pub/sub).
 *  - Enforces tiered blocking (temporary, permanent, geo-based).
 *  - Integrated with telemetry + audit logging.
 *
 * Design Goals:
 *  - Fast: O(1) IP lookup via Redis hash.
 *  - Smart: Graceful fallback if Redis or AbuseIPDB unavailable.
 *  - Observable: All blocks are auditable and traceable.
 * --------------------------------------------------------------------------
 */

import { Request, Response, NextFunction } from "express";
import { redisClient } from "../lib/redisClient";
import { logger } from "../logger";
import { telemetry } from "../lib/telemetry";
import { auditService } from "../services/audit.service";
import { checkIpReputation } from "../integrations/abuseipdb.service";
import { config } from "../config";
import geoip from "geoip-lite";

const redis = redisClient();
const BLOCKLIST_KEY = "security:ip:blocklist";
const ALLOWLIST_KEY = "security:ip:allowlist";
const DEFAULT_BLOCK_DURATION_SEC = 60 * 60 * 24; // 24 hours

/* --------------------------------------------------------------------------
 * üß† Helper: Check if IP is blocklisted
 * -------------------------------------------------------------------------- */
async function isIpBlocked(ip: string): Promise<boolean> {
  try {
    const allowed = await redis.hexists(ALLOWLIST_KEY, ip);
    if (allowed) return false;

    const blocked = await redis.hget(BLOCKLIST_KEY, ip);
    if (!blocked) return false;

    const record = JSON.parse(blocked);
    if (record.expiresAt && Date.now() > record.expiresAt) {
      await redis.hdel(BLOCKLIST_KEY, ip); // expire
      return false;
    }

    return true;
  } catch (err: any) {
    logger.error(`[IP BLOCKLIST] Redis check failed: ${err.message}`);
    return false;
  }
}

/* --------------------------------------------------------------------------
 * ‚öôÔ∏è Helper: Add IP to blocklist
 * -------------------------------------------------------------------------- */
export async function blockIp(
  ip: string,
  reason = "security_violation",
  durationSec = DEFAULT_BLOCK_DURATION_SEC
) {
  try {
    const expiresAt = Date.now() + durationSec * 1000;
    const record = { reason, expiresAt };

    await redis.hset(BLOCKLIST_KEY, ip, JSON.stringify(record));

    telemetry.record("security.ip_blocked", 1, "counter");
    logger.warn(`[IP BLOCKLIST] üö´ Blocked IP: ${ip} (reason: ${reason})`);

    await auditService.log({
      actorId: ip,
      actorRole: "system",
      action: "IP_BLOCKLIST_ADD",
      details: { ip, reason, durationSec },
    });
  } catch (err: any) {
    logger.error(`[IP BLOCKLIST] Failed to block IP ${ip}: ${err.message}`);
  }
}

/* --------------------------------------------------------------------------
 * ‚öôÔ∏è Helper: Remove IP from blocklist
 * -------------------------------------------------------------------------- */
export async function unblockIp(ip: string) {
  try {
    await redis.hdel(BLOCKLIST_KEY, ip);
    telemetry.record("security.ip_unblocked", 1, "counter");
    logger.info(`[IP BLOCKLIST] ‚úÖ Unblocked IP: ${ip}`);

    await auditService.log({
      actorId: "system",
      actorRole: "system",
      action: "IP_BLOCKLIST_REMOVE",
      details: { ip },
    });
  } catch (err: any) {
    logger.error(`[IP BLOCKLIST] Failed to unblock IP ${ip}: ${err.message}`);
  }
}

/* --------------------------------------------------------------------------
 * üåç Geo-based Blocking (Optional)
 * -------------------------------------------------------------------------- */
async function checkGeoBlock(ip: string): Promise<boolean> {
  try {
    const geo = geoip.lookup(ip);
    const blockedCountries = config.security?.blockedCountries || [];

    if (geo && geo.country && blockedCountries.includes(geo.country)) {
      logger.warn(`[IP BLOCKLIST] üåç Country blocked (${geo.country}) for IP ${ip}`);
      return true;
    }

    return false;
  } catch (err: any) {
    logger.error(`[IP BLOCKLIST] GeoIP lookup failed: ${err.message}`);
    return false;
  }
}

/* --------------------------------------------------------------------------
 * üö® Middleware: Enforce Blocklist + Reputation + Geo rules
 * -------------------------------------------------------------------------- */
export async function ipBlocklistMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
) {
  try {
    const ip =
      req.headers["x-forwarded-for"]?.toString().split(",")[0].trim() ||
      req.ip ||
      req.socket.remoteAddress ||
      "unknown";

    // Skip localhost/internal
    if (ip === "127.0.0.1" || ip.includes("::1")) return next();

    // 1Ô∏è‚É£ Local allowlist check
    const allowlisted = await redis.hexists(ALLOWLIST_KEY, ip);
    if (allowlisted) return next();

    // 2Ô∏è‚É£ Local blocklist check
    const blocked = await isIpBlocked(ip);
    if (blocked) {
      telemetry.record("security.ip_blocked_request", 1, "counter");
      logger.warn(`[IP BLOCKLIST] üö´ Blocked incoming request from ${ip}`);
      return res.status(403).json({
        success: false,
        message: "Access denied ‚Äî IP is blocklisted.",
      });
    }

    // 3Ô∏è‚É£ Geo-blocking
    const geoBlocked = await checkGeoBlock(ip);
    if (geoBlocked) {
      await blockIp(ip, "geo_block");
      return res.status(403).json({
        success: false,
        message: "Access denied ‚Äî region restricted.",
      });
    }

    // 4Ô∏è‚É£ Reputation-based auto-block (via AbuseIPDB)
    const reputation = await checkIpReputation(ip);
    if (reputation?.isBlacklisted) {
      await blockIp(ip, "abuseipdb_blacklisted");
      return res.status(403).json({
        success: false,
        message: "Access denied ‚Äî high-risk IP detected.",
      });
    }

    // ‚úÖ Passed all checks
    next();
  } catch (err: any) {
    logger.error(`[IP BLOCKLIST] Middleware error: ${err.message}`);
    next();
  }
}

/* --------------------------------------------------------------------------
 * üßπ Maintenance Utilities
 * -------------------------------------------------------------------------- */
export async function purgeExpiredBlocks() {
  try {
    const all = await redis.hgetall(BLOCKLIST_KEY);
    let purged = 0;

    for (const [ip, recordStr] of Object.entries(all)) {
      try {
        const record = JSON.parse(recordStr);
        if (record.expiresAt && Date.now() > record.expiresAt) {
          await redis.hdel(BLOCKLIST_KEY, ip);
          purged++;
        }
      } catch {}
    }

    if (purged > 0) {
      logger.info(`[IP BLOCKLIST] üßπ Purged ${purged} expired block entries.`);
      telemetry.record("security.ipblocklist.purged", purged, "counter");
    }
  } catch (err: any) {
    logger.error(`[IP BLOCKLIST] Failed to purge expired IP blocks: ${err.message}`);
  }
}

/* --------------------------------------------------------------------------
 * üì¶ Exports
 * -------------------------------------------------------------------------- */
export default {
  ipBlocklistMiddleware,
  blockIp,
  unblockIp,
  purgeExpiredBlocks,
};