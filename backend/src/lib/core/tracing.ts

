/**
 * src/lib/core/tracing.ts
 * --------------------------------------------------------------------------
 * ðŸŽ¯ Enterprise Tracing Utility Layer
 *
 * Purpose:
 *  - Unified custom tracing abstraction built over OpenTelemetry.
 *  - Simplifies span creation, attribute setting, error tagging, and timing.
 *  - Integrates tracing with logger + telemetry + metrics subsystems.
 *  - Enables consistent instrumentation across API, queues, workers, and AI.
 *
 *  Designed for:
 *  - Enterprise observability
 *  - Low overhead + graceful fallback when OTel is unavailable
 *  - Seamless cross-service correlation (via trace + request IDs)
 */

import { context, trace, Span, SpanKind, SpanStatusCode } from "@opentelemetry/api";
import { performance } from "perf_hooks";
import { telemetry } from "../telemetry";
import { logger } from "../../logger";
import { config } from "../../config";
import { observabilityConfig } from "../../config/observabilityConfig";
import { randomUUID } from "crypto";

/* ------------------------------------------------------------------------
   ðŸ§± TracingContext Interface
------------------------------------------------------------------------ */
export interface TracingContext {
  traceId: string;
  spanId: string;
  parentSpanId?: string;
  requestId?: string;
  serviceName: string;
  environment: string;
}

/* ------------------------------------------------------------------------
   ðŸŽ¯ Core Tracing Manager
------------------------------------------------------------------------ */
class TracingManager {
  private tracer = trace.getTracer(observabilityConfig.serviceName);

  /**
   * Start a new span
   */
  startSpan(
    name: string,
    kind: SpanKind = SpanKind.INTERNAL,
    attributes?: Record<string, any>
  ): Span | null {
    try {
      const span = this.tracer.startSpan(name, {
        kind,
        attributes: {
          service: observabilityConfig.serviceName,
          environment: config.NODE_ENV,
          ...attributes,
        },
      });
      return span;
    } catch (err: any) {
      logger.warn(`[Tracing] Failed to start span: ${err.message}`);
      return null;
    }
  }

  /**
   * End span safely with status
   */
  endSpan(span: Span | null, status: "ok" | "error" = "ok", error?: any) {
    if (!span) return;
    try {
      if (status === "ok") {
        span.setStatus({ code: SpanStatusCode.OK });
      } else {
        span.setStatus({ code: SpanStatusCode.ERROR, message: error?.message || "Error" });
        span.recordException(error);
      }
      span.end();
    } catch (err: any) {
      logger.warn(`[Tracing] Failed to end span: ${err.message}`);
    }
  }

  /**
   * Wrap async function in span
   */
  async traceAsync<T>(
    name: string,
    fn: () => Promise<T>,
    attributes?: Record<string, any>
  ): Promise<T> {
    const span = this.startSpan(name, SpanKind.INTERNAL, attributes);
    const start = performance.now();

    try {
      const ctx = trace.setSpan(context.active(), span!);
      const result = await context.with(ctx, fn);
      const duration = performance.now() - start;

      // Record metrics
      telemetry.record(`${name}.duration_ms`, duration, "timer");

      this.endSpan(span, "ok");
      return result;
    } catch (err: any) {
      const duration = performance.now() - start;
      telemetry.record(`${name}.error_duration_ms`, duration, "timer");
      logger.error(`[Tracing] ${name} failed: ${err.message}`, { name, err });
      this.endSpan(span, "error", err);
      throw err;
    }
  }

  /**
   * Wrap sync function in span
   */
  traceSync<T>(name: string, fn: () => T, attributes?: Record<string, any>): T {
    const span = this.startSpan(name, SpanKind.INTERNAL, attributes);
    const start = performance.now();
    try {
      const result = fn();
      const duration = performance.now() - start;
      telemetry.record(`${name}.duration_ms`, duration, "timer");
      this.endSpan(span, "ok");
      return result;
    } catch (err: any) {
      const duration = performance.now() - start;
      telemetry.record(`${name}.error_duration_ms`, duration, "timer");
      logger.error(`[Tracing] ${name} failed: ${err.message}`, { name, err });
      this.endSpan(span, "error", err);
      throw err;
    }
  }

  /**
   * Extract tracing metadata (for logging / external calls)
   */
  getContext(span?: Span): TracingContext {
    try {
      const spanCtx = (span || trace.getActiveSpan())?.spanContext();
      return {
        traceId: spanCtx?.traceId || randomUUID(),
        spanId: spanCtx?.spanId || randomUUID(),
        serviceName: observabilityConfig.serviceName,
        environment: config.NODE_ENV,
      };
    } catch {
      return {
        traceId: randomUUID(),
        spanId: randomUUID(),
        serviceName: observabilityConfig.serviceName,
        environment: config.NODE_ENV,
      };
    }
  }

  /**
   * Propagate tracing context downstream (for headers)
   */
  getPropagationHeaders(span?: Span): Record<string, string> {
    const ctx = this.getContext(span);
    return {
      "x-trace-id": ctx.traceId,
      "x-span-id": ctx.spanId,
      "x-service": ctx.serviceName,
      "x-env": ctx.environment,
    };
  }

  /**
   * Log combined trace + telemetry context
   */
  logWithTrace(level: "info" | "warn" | "error", message: string, meta?: any) {
    const ctx = this.getContext();
    logger[level](`[TRACE:${ctx.traceId}] ${message}`, {
      traceId: ctx.traceId,
      spanId: ctx.spanId,
      ...meta,
    });
  }
}

/* ------------------------------------------------------------------------
   ðŸš€ Singleton Export
------------------------------------------------------------------------ */
export const tracing = new TracingManager();

/**
 * Quick helper for async tracing
 */
export const withTrace = async <T>(
  name: string,
  fn: () => Promise<T>,
  attributes?: Record<string, any>
): Promise<T> => tracing.traceAsync(name, fn, attributes);

/**
 * Quick helper for sync tracing
 */
export const withTraceSync = <T>(
  name: string,
  fn: () => T,
  attributes?: Record<string, any>
): T => tracing.traceSync(name, fn, attributes);

/**
 * Access trace context
 */
export const traceContext = () => tracing.getContext();

/**
 * Generate trace headers (for outbound HTTP calls)
 */
export const traceHeaders = () => tracing.getPropagationHeaders();

/**
 * Safe trace logger (combines logger + trace IDs)
 */
export const traceLog = (message: string, meta?: any) => {
  tracing.logWithTrace("info", message, meta);
};

/* ------------------------------------------------------------------------
   ðŸ§© Example usage in a service:
------------------------------------------------------------------------ */
/*
import { withTrace, traceLog } from "@/lib/core/tracing";

await withTrace("user.service.createUser", async () => {
  traceLog("Creating new user...");
  const user = await prisma.user.create({ data: {...} });
  return user;
});
*/