/**
 * src/lib/rateLimiterRedis.ts
 * --------------------------------------------------------------------------
 * üö¶ Enterprise Distributed Rate Limiter (v3.2)
 *
 * Features:
 *  - Global, per-user, or per-IP rate limiting
 *  - Fixed or Sliding Window (ZSET-based)
 *  - Atomic Redis operations (safe for cluster)
 *  - Built-in alert throttling to prevent spam
 *  - Integrated with OpenTelemetry, Prometheus, and audit logs
 *  - Express middleware with full observability and safe fallbacks
 * --------------------------------------------------------------------------
 */

import { redisClient } from "./redisClient";
import { context, trace, SpanStatusCode } from "@opentelemetry/api";
import { logger } from "../logger";
import { recordError, recordMetric } from "./core/metrics";
import { auditService } from "../services/audit.service";
import { config } from "../config";

export interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  limit: number;
  resetIn: number;
}

export interface RateLimitOptions {
  keyPrefix?: string;
  windowSec?: number;
  maxRequests?: number;
  sliding?: boolean;
  userId?: string;
  ip?: string;
  alertOnAbuse?: boolean;
}

/* --------------------------------------------------------------------------
 * ‚öôÔ∏è Core Implementation
 * -------------------------------------------------------------------------- */
export const rateLimiterRedis = async (
  identifier: string,
  opts: RateLimitOptions = {}
): Promise<RateLimitResult> => {
  const r = redisClient() as any;
  const tracer = trace.getTracer("infra.rateLimiter");
  const span = tracer.startSpan("rateLimiterRedis.check", undefined, context.active());

  const prefix = opts.keyPrefix || "ratelimit";
  const windowSec = opts.windowSec ?? 60;
  const maxRequests = opts.maxRequests ?? 30;
  const sliding = opts.sliding ?? false;
  const key = `${prefix}:${identifier}`;

  try {
    const now = Date.now();
    const ttlMs = windowSec * 1000;

    let count = 0;
    let allowed = true;
    let resetIn = ttlMs;

    if (!sliding) {
      // üîí Fixed window algorithm
      const pipeline = r.multi();
      pipeline.incr(key);
      pipeline.ttl(key);
      const [incrRes, ttlRes] = await pipeline.exec().then((res: any[]) => res.map((r) => r[1]));

      count = incrRes ?? 0;
      const ttl = ttlRes ?? -1;

      if (ttl === -1) await r.expire(key, windowSec);

      allowed = count <= maxRequests;
      resetIn = ttl > 0 ? ttl * 1000 : ttlMs;
    } else {
      // üß† Sliding window algorithm
      const windowStart = now - ttlMs;
      const pipeline = r.multi();
      pipeline.zremrangebyscore(key, 0, windowStart);
      pipeline.zadd(key, now, `${now}-${Math.random()}`);
      pipeline.zcard(key);
      pipeline.pexpire(key, ttlMs);
      const [, , zCount] = await pipeline.exec().then((res: any[]) => res.map((r) => r[1]));

      count = zCount ?? 0;
      allowed = count <= maxRequests;
    }

    const remaining = Math.max(0, maxRequests - count);

    // telemetry metrics
    recordMetric("rate_limiter_requests_total", 1, { identifier });
    recordMetric("rate_limiter_requests_exceeded", allowed ? 0 : 1, { identifier });

    span.setAttributes({ key, count, allowed, windowSec, maxRequests, sliding });
    span.setStatus({ code: allowed ? SpanStatusCode.OK : SpanStatusCode.ERROR });
    span.end();

    if (!allowed && opts.alertOnAbuse !== false) {
      await handleAbuse(identifier, count, maxRequests);
    }

    return { allowed, remaining, limit: maxRequests, resetIn };
  } catch (err: any) {
    recordError("rate_limiter_error", "medium");
    span.recordException(err);
    span.setStatus({ code: SpanStatusCode.ERROR, message: err.message });
    span.end();

    logger.error(`[RateLimiter] ‚ùå Error checking rate limit: ${err.message}`);
    return {
      allowed: true,
      remaining: opts.maxRequests ?? 30,
      limit: opts.maxRequests ?? 30,
      resetIn: 0,
    };
  }
};

/* --------------------------------------------------------------------------
 * üö® Abuse & Alert Handling (smart + throttled)
 * -------------------------------------------------------------------------- */
const recentAlerts: Record<string, number> = {}; // prevent alert spam

const handleAbuse = async (identifier: string, count: number, max: number) => {
  const now = Date.now();
  const lastAlert = recentAlerts[identifier] || 0;
  if (now - lastAlert < 30_000) return; // throttle alert per 30s
  recentAlerts[identifier] = now;

  const ratio = (count / max).toFixed(2);
  logger.warn(`[RateLimiter] ‚ö†Ô∏è Rate limit exceeded by ${identifier} (${count}/${max})`);

  try {
    await auditService.log({
      actorId: identifier,
      actorRole: "user",
      action: "RATE_LIMIT_EXCEEDED",
      details: { identifier, count, max, ratio, timestamp: new Date().toISOString() },
    });
  } catch (err: any) {
    logger.error("[RateLimiter] Failed to log abuse to audit service:", err.message);
  }

  // üîî TODO: Optionally integrate with alert.worker.ts for critical actors or IPs
};

/* --------------------------------------------------------------------------
 * üß© Express Middleware Wrapper
 * -------------------------------------------------------------------------- */
export const rateLimiterMiddleware =
  (opts: RateLimitOptions = {}) =>
  async (req: any, res: any, next: any) => {
    try {
      const identifier =
        opts.userId ||
        req.user?.id ||
        req.ip ||
        req.headers["x-forwarded-for"] ||
        "anonymous";

      const result = await rateLimiterRedis(identifier, opts);

      res.setHeader("X-RateLimit-Limit", result.limit);
      res.setHeader("X-RateLimit-Remaining", result.remaining);
      res.setHeader("X-RateLimit-Reset", Math.ceil(result.resetIn / 1000));

      if (!result.allowed) {
        logger.info(
          `[RateLimiter] Rejected request for ${identifier} ‚Äî retry in ${Math.ceil(
            result.resetIn / 1000
          )}s`
        );
        return res.status(429).json({
          success: false,
          message: "Too many requests. Please slow down.",
          retryAfter: Math.ceil(result.resetIn / 1000),
        });
      }

      next();
    } catch (err: any) {
      logger.error("[RateLimiter] Middleware error:", err.message);
      next();
    }
  };

/* --------------------------------------------------------------------------
 * üß† Example Usage
 * --------------------------------------------------------------------------
 * import express from "express";
 * import { rateLimiterMiddleware } from "../lib/rateLimiterRedis";
 *
 * const app = express();
 * // Apply a global rate limit
 * app.use("/api/", rateLimiterMiddleware({ windowSec: 60, maxRequests: 50 }));
 *
 * // Apply user-specific stricter rate limit
 * app.post("/api/auth/login", rateLimiterMiddleware({ windowSec: 30, maxRequests: 5 }));
 *
 * // Works seamlessly across scaled API nodes via Redis cluster.
 * -------------------------------------------------------------------------- */

export default {
  rateLimiterRedis,
  rateLimiterMiddleware,
};